# Astro 520 PSET 1
#### Peter Bowman-Davis, Sept 24, 2023

#### 1. Open a file, write a billion numbers into it, close the file. Compare runtime + storage size of file produced by:
1.1: Writing out the numbers as human readable characters (ASCII, using the fprintf subroutine). 
    
    See: numberGenASCII.c 
    Runtime = 75sec, file size = 10.1GB

1.2: Once by copying the binary representation of each number to the file (using fprintf subroutine). 
    
    See: numberGenBinaryFprintf.c 
    Runtime: 157475.10 milliseconds, file size = 33.0GB

This low degree of performance can be seen as essentially the 'worst of both worlds': a lack of easily human readable text, encoded in a format that is built for human-readability rather than compression efficiency. 

1.3: Once by dumping the entire array in shot using a low level “write” subroutine
    
    See: numberGenBinary.c 
    Runtime = 27sec, file size = 4.0GB


#### 2. Write two simple programs that read each number in from the file and then add it to a running sum (for the average) and running sum of the square of the numbers (for the standard deviation) in order to compute the average of the numbers (first program) and the standard deviation of the numbers (second program).

2.1: See `Avg.c` and `stdDev.c` (which support binary outputs generated by the likes of `numberGenBinary.c`)

#### 2.2: Rewrite your random number generation program so that it uses fprint to print the numbers to the standard output “file”, stdout. When you run this program by itself, you should see a billion numbers scroll by on your screen (the default for information sent to “stdout” – it shows up on your display).

2.2.1: See `numberGenAsciiStdOut.c` and `numberGenBinaryStdOut.c`. 

#### 2.3: Rewrite the program to compute the average so it that reads its numbers from the standard input “file” instead of from the random number generation file until it reaches an end-of-file condition. (If you don’t specify what “stdin” is hooked into, it takes input from your keyboard by default). Test it by typing a few random numbers by hand and then typing “ctrl-D” (End-of-File=EOF) to signal to the program that you’re done inputting numbers. Verify that the average of the numbers you typed is properly computed.

2.3.1: See `avgFromInput.c` and `avgFromBinaryInput.c`. 

#### 2.4: Now the magic. If your random number generation program is called “gen_stdout”, and your average computation program is called “stdin_ave,” type the compound command, “gen_stdout | stdin_ave ” . This (something that uses the “|” operator) is known as “using a pipe to connect two streams.” Instead of you having to create your big billion number file, Unix does it for you automatically. It takes the numbers from generation program, writes them to a temporary file on disk, and while it’s writing them, it also starts reading them in and feeding them to your averaging program (making sure to pause temporarily, if necessary, the averaging program if there are no new numbers in the temporary file, e.g., because the generation program is very slow .) This temporary file is an example of a “buffer” which will talk about more later, and has the advantage that if the rate at which numbers are read out of it is close to the rate at which they are written into it, then the file may be very small.

2.4.1: Verified. Running `./numberGenAsciiStdOut | ./avgFromInput` when n=1000 yields `Count: 1000
Average: 4.421000`. 

#### 2.5: For fun, and to see the power of the Unix approach, let’s say you now want to generate a list of random numbers that is sorted. Since sorting is an expensive operation, let’s reduce the total number of we create to 1000 (enough to prove the concept). Then do, “ gen_stdout | sort > sorted_num.dat ” . This pipes our random numbers through the sort program, which spits out a sorted list of numbers to standard output, which we then conveniently capture using the “>” I/O redirection operator and place in the file, sorted_num.dat. I challenge you to try doing that by programming everything yourself from scratch ... J The modular Unix approach just takes a few seconds to set up.

2.5.1: Verified. Running `./numberGenAsciiStdOut | sort > sorted.dat` yields a file called `sorted.dat` that contains a sorted list of random numbers.


#### 3: Last step. Let’s learn how to make a fast histogram using the algorithm discussed in class. Write a program to “bin up” your numbers by tenths, and print out/write to a file the number of random numbers generated that had values between 0 and 0.1, between 0.1 and 0.2, between 0.2 and 0.3, etc. [So your billion number file effectively gets turned into a ten number file.] Make a bar plot (histogram) showing the number of values found in each interval (“bin”).

See programs `numberGenBinary.c`, `bins.c`, and `plotHist.py`, as well as figure `figure.png`, and the following results after n=1e9:

Counts (RNG integers in set [0,9]):

    0: 99996690
    1: 99997760
    2: 99984541
    3: 99995878
    4: 100012593
    5: 100006873
    6: 100002599
    7: 100001422
    8: 99999166
    9: 100002478
